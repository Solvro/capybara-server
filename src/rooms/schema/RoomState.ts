import { type, Schema, ArraySchema } from "@colyseus/schema";
import { Position } from "./Position.js";
import { PlayerState } from "./PlayerState.js";
import { CrateState } from "./CrateState.js";
import { ButtonState } from "./ButtonState.js";
import { DoorState } from "./DoorState.js";
import { VentState } from "./VentState.js";
import { Capybara } from "./Capybara.js";

export class RoomState extends Schema {
  @type(["string"]) grid = new ArraySchema<string>();
  @type("number") width: number = 10;
  @type("number") height: number = 7;

  @type([Position]) startingPositions = new ArraySchema<Position>();

  @type(PlayerState) playerState: PlayerState = new PlayerState();
  @type(CrateState) crateState: CrateState = new CrateState();
  @type(DoorState) doorState: DoorState = new DoorState();
  @type(ButtonState) buttonState: ButtonState = new ButtonState();
  @type(VentState) ventState: VentState = new VentState();
  @type(Capybara) capybara: Capybara;

  loadRoomFromJson(jsonData: any) {
    try {
      this.width = jsonData.width;
      this.height = jsonData.height;

      this.grid = new ArraySchema<string>(...jsonData.layout);

      this._loadMechanics(jsonData.mechanics);

      for (const crateData of jsonData.entities.crates) {
        this.crateState.createCrate(crateData.x, crateData.y);
      }

      for (const playerData of jsonData.entities.players) {
        this.startingPositions.push(
          new Position().assign({ x: playerData.x, y: playerData.y })
        );
      }
      this.ventState.spawnInitialVents();
      this.spawnCapybara();

    } catch (error) {
      throw `Error loading room data: ${error}`;
    }
  }

  _loadMechanics(mechanicsData: any) {
    for (const mechanicData of mechanicsData) {
      const mechanicType = mechanicData.type;

      if (mechanicType === "door") {
        this.doorState.createDoor(
          mechanicData.id,
          mechanicData.color,
          mechanicData.x,
          mechanicData.y
        );
      } else if (mechanicType === "button") {
        this.buttonState.createButton(
          mechanicData.id,
          mechanicData.color,
          mechanicData.x,
          mechanicData.y,
          mechanicData.doorId
        );
      }
    }
  }

  getCellValue(x: number, y: number): string {
    return this.grid[y * this.width + x];
  }

  getGridAs2DArray(): string[][] {
    const array2D: string[][] = [];

    for (let y = 0; y < this.height; y++) {
      const row: string[] = [];
      for (let x = 0; x < this.width; x++) {
        const cell = this.getCellValue(x, y);
        row.push(cell);
      }
      array2D.push(row);
    }
    return array2D;
  }

  isWalkableForPlayer(x: number, y: number): boolean {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
      return false;
    }
    return (
      this.getCellValue(x, y).startsWith("f") &&
      this.crateState.getCrateAt(x, y) === null &&
      this.doorState.isOpenOrEmptyAt(x, y)
    );
  }

  isWalkableForCrate(x: number, y: number): boolean {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) return false;

    const cell = this.getCellValue(x, y);
    if (!cell.startsWith("f")) return false;

    const playerOccupies = [...this.playerState.players.values()].some(
      (p) => p.position.x === x && p.position.y === y
    );
    if (playerOccupies) return false;

    if (!this.doorState.isOpenOrEmptyAt(x, y)) return false;

    return true;
  }

  isWalkableForCapybara(x: number, y: number): boolean {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) return false;

    const cell = this.getCellValue(x, y);

    if (cell.startsWith("w")) return false;

    if (this.crateState.getCrateAt(x, y)) return false;

    if (!this.doorState.isOpenOrEmptyAt(x, y)) return false;

    return true;
  }

  reconstructPath(parents: Map<string, {x: number; y: number}>, endNode: {x: number; y: number}): { x: number; y: number}[] {
    const path = [endNode];
    let current = endNode;
    let parent = parents.get(`${current.x}_${current.y}`)
    
    while (parent) {
      current = parent;
      const key = `${current.x}_${current.y}`
      parent = parents.get(key)
      path.push(current)
    }

    return path.reverse();
  }

  findPathToVent(): {x: number; y: number}[] | null {
    const startNode = { 
      x: this.capybara.position.x,
      y: this.capybara.position.y,
     }

     const  queue: {x: number, y: number}[] = [];
     queue.push(startNode);

     const visited = new Set<string>();
     visited.add(`${startNode.x}_${startNode.y}`);

     const parents = new Map<string, { x: number, y: number }>();
     const delta = [{x:0, y:1}, {x:0, y:-1}, {x:1, y:0}, {x:-1, y:0}];

     while (!(queue.length === 0)) {
        let current = queue.shift()!;
        if (this.ventState.getVentAt(current.x, current.y) && this.ventState.isOpenOrEmptyAt(current.x, current.y)) {
          return this.reconstructPath(parents, current);
        }


        for (const nextMove of delta) {
          let [nextX, nextY] = [current.x + nextMove.x, current.y + nextMove.y];
          let nextKey: string = `${nextX}_${nextY}`
          if (visited.has(nextKey)) continue;
          if (!this.isWalkableForCapybara(nextX, nextY)) continue;
          if (!this.ventState.isOpenOrEmptyAt(nextX, nextY)) continue;

          visited.add(nextKey);
          parents.set(nextKey, current);
          queue.push({x: nextX,  y: nextY});
        }
     }
     // console.log("no possible way :(")
     return null
  }

  spawnNewPlayer(sessionId: string, name: string = null) {
    this.playerState.createPlayer(sessionId, name);
    const player = this.playerState.players.get(sessionId);
    const startingPos =
      this.startingPositions[player.index % this.startingPositions.length];
    player.position.x = startingPos.x;
    player.position.y = startingPos.y;
  }

  despawnPlayer(sessionId: string) {
    this.playerState.removePlayer(sessionId);
  }

  onRoomDispose() {
    this.playerState.onRoomDispose();
    this.crateState.onRoomDispose();
    this.doorState.onRoomDispose();
    this.buttonState.onRoomDispose();
  }

  movePlayer(sessionId: string, deltaX: number, deltaY: number): boolean {
    const player = this.playerState.players.get(sessionId);

    const newX = player.position.x + deltaX;
    const newY = player.position.y + deltaY;

    if (this.isWalkableForPlayer(newX, newY)) {
      player.position.x = newX;
      player.position.y = newY;
      return true;
    }

    const crate = this.crateState.getCrateAt(newX, newY);
    if (crate && this.moveCrate(crate.id, deltaX, deltaY)) {
      player.position.x = newX;
      player.position.y = newY;
      return true;
    }

    return false;
  }

  getMapInfo() {
    return {
      grid: this.getGridAs2DArray(),
      width: this.width,
      height: this.height,
      players: Array.from(this.playerState.players.values()).map((player) => {
        return {
          index: player.index,
          name: player.name,
          x: player.position.x,
          y: player.position.y,
          sessionId: player.sessionId,
        };
      }),
      crates: Array.from(this.crateState.crates.values()).map((crate) => {
        return {
          crateId: crate.id,
          x: crate.position.x,
          y: crate.position.y,
        };
      }),
      doors: Array.from(this.doorState.doors.values()).map((door) => ({
        doorId: door.id,
        color: door.color,
        x: door.position.x,
        y: door.position.y,
        open: door.open,
      })),
      buttons: Array.from(this.buttonState.buttons.values()).map((button) => ({
        buttonId: button.id,
        color: button.color,
        x: button.position.x,
        y: button.position.y,
        pressed: button.pressed,
      })),
    };
  }

  getGrid() {
    return this.getGridAs2DArray();
  }

  getWidth() {
    return this.width;
  }

  getHeight() {
    return this.height;
  }

  getPlayerName(sessionId: string): string {
    return this.playerState.getPlayerName(sessionId);
  }

  despawnCrate(id: string) {
    this.crateState.removeCrate(id);
  }

  moveCrate(crateId: string, dx: number, dy: number): boolean {
    const crate = this.crateState.crates.get(crateId);
    if (!crate) return false;

    const targetX = crate.position.x + dx;
    const targetY = crate.position.y + dy;

    if (!this.isWalkableForCrate(targetX, targetY)) return false;

    const nextCrate = this.crateState.getCrateAt(targetX, targetY);
    if (nextCrate && !this.moveCrate(nextCrate.id, dx, dy)) return false;

    const oldX = crate.position.x;
    const oldY = crate.position.y;

    this.crateState.moveCratesBlock(oldX, oldY, targetX, targetY, dx, dy);

    crate.position.x = targetX;
    crate.position.y = targetY;

    return true;
  }

  checkButtonPressed() {
    const doorsAndButtonsToUpdate: {
      doorId: string;
      buttonId: string;
      open: boolean;
    }[] = [];

    for (const button of this.buttonState.buttons.values()) {
      const playerOnButton = [...this.playerState.players.values()].some(
        (p) =>
          p.position.x === button.position.x &&
          p.position.y === button.position.y
      );

      const crateOnButton = !!this.crateState.getCrateAt(
        button.position.x,
        button.position.y
      );

      const door = this.doorState.doors.get(button.doorId);
      if (!door) return;

      const shouldOpen = playerOnButton || crateOnButton;
      if (door.open !== shouldOpen) {
        door.open = shouldOpen;
        button.pressed = shouldOpen;
        doorsAndButtonsToUpdate.push({
          doorId: door.id,
          buttonId: button.id,
          open: door.open,
        });
      }
    }
    return doorsAndButtonsToUpdate;
  }

  spawnCapybara() {
    const startingPos = new Position();
    startingPos.x = 3;
    startingPos.y = 4;
    this.capybara = new Capybara(startingPos.x, startingPos.y)
  }
}
